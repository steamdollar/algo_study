/*
동적 프로그래밍, 재귀를 사용해야할 것 같음.
일단 작은 걸로 시작해, 큰걸 구하자.
변수는 base block의 width, 전체 블럭의 height.
여기서 width는 상수로 주어진다.
그래도 1에서 w까지 도달하는데 어차피 필요할 것 같음.
f(w,h) = f(?,?) + ... (1 <= w, h <= 10)
이런식으로 나올 것 같다.

플레 문제지만 어려운 cs 지식이 들어가는 것 같지 않고
점화식 들어가는 수학 문제에 가까운 것 같다.

f(w, 0) = 1
f(1, h) = h + 1
//
f(2, 1) = 1 + 2 + 1 + 1 = 5
f(2,2) = f(2, 1) +

뭐 하나를 고정해놓고 생각을 해야겠다.
w = 5 로 고정을 하고, 높이들 간의 관계에 대해 생각해보자.
h = 0 이면 f(5,0) = 1

이제 첫 한 층을 채우는 경우의 수를 생각해보자.
즉 f(5,1)을 어떻게 구할지 생각해보자.

이건 조합 문제가 된다.

w3, w2, w1, e(빈칸 하나)를 적절히 사용해 w를 채운다.

우선 w=3 block을 사용하는 갯수에 따라 경우를 나누고, 그 다음 w2, 그 다음 w1, e...

w3, w2 block의 갯수를 정하면

w1, e를 배치하는 경우의 수는 2^n으로 구할 수 있고,

그 다음 w2, w3를 적절히 배치해주면 된다.

예를 들어 w = 7이고 w3 = 1, w2 = 0 하면

4칸이 남고, 각각의 칸에 w1 혹은 e를 정해줘야하는데, 이는 2^4

그 후 1, e를 동일하다고 보고, w3, w1의 위치를 결정하면 된다.

아니면 크기 생각하지말고 배치만 해도 된다.

이제 다음 층으로 가보자.

i) 아래 층이 가득 찬 경우
하나도 빠짐 없이 아래층이 찼다면 이번 층은 아래층과 동일한 방법으로 채워줄 수 있다.
즉 f(w, h+1) = f(w, h)

ii) 그렇지 않은 경우
만약 중간에 빈칸이 있는 경우 이걸 w3으로 이어줄 수 있는지가 중요해진다.

w7에서 w2, e, w2, w1, e 로 쌓았을 경우,

그 위에 쌓는 층은 w2, w3 두 개 사이에 빈 칸이 하나 있는 것과 같고

결과적으로 f(2,1) + f(3,1) + (w3 block으로 두 섬을 이은 경우)를 세야 함.

이전 층의 블럭들 사이에 빈칸이 두 개 이상 있어 w3로 이을 수 없다면 그냥 각각을 다시 계산하면 된다.

(현재 높이는 별로 안 중요하다. 그 이전 층의 구성이 중요하다.)

재귀적으로 푸는게 맞는 것 같다.

각 base block의 넓이 = 1, 2... 의 경우를 메모이제이션해두면 연산도 많지 않게 될 것 같음.

결국 base = 1, 2, 3의 경우의 조합으로 환원될 것.

한 층만 쌓는 경우를 생각해보면
f(1, 1) = 2 [(0), (1)] // f(1, h) = h+1
f(2, 1) = 5 [ (2), (1,1), (1,0), (0,1), (0,0) ]
f(3, 1) = 13 [(3), (2, 1), (1, 2), (2, 0), (0, 2), (1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 0), (1, 0, 1), (0, 1, 1), (1, 1, 1), (0, 0, 0)]

f(2,2) = f(2,1) + f(2,1) + f(1,1) + f(1,1)
*/
package main

import "fmt"

func main() {
        var w,h int
        fmt.Scanf("%d %d", &w, &h)
        
        fmt.Println(w, h)
}