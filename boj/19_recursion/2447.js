// let n = +require("fs").readFileSync("/dev/stdin").toString().trim();

// 1. 크기 n의 * 스퀘어를 만든다.
// 2. 중앙에 크기 n/3 스퀘어를 뚫는다.
// 3. 남은 n/3 스퀘어 8개에 대해 반복
// 4. n = 3 인 경우엔 기본블럭을 그린다.

// 재귀의 방식을 코드화하는 것에 더해 별 찍는거 출력을 어떻게 할건지도 어려움..
// * 하나가 아니라 기본 블럭을 가지고 사고를 하는게 좋을 것 같다.
//
// ***
// * *
// ***
// 이거 가지고..
// a(n+1) = a(n) + a(n) + a(n)
//        + a(n) +      + a(n)
//        + a(n) + a(n) + a(n)
// a(1) = *** + \n + * * + \n + ***

// 근데 줄을 한 번 바꿔버리면 다시 윗줄로 돌아가는게 안되는데..
// 이중 반복문을 써야하나?
// 그래서 각 줄마다 *인지 공백인지를 하나 하나 정해줘야 하나?

// 각 가로줄을 배열로 생각하는게 좋을 것 같다.
// N = 3^n
// memo = [3^n][3^n]bool
// 3^n * 3^n 개를 전부 true로 채운다.
// 중앙 3^n-1 * 3^n-1 개를 false로 바꾼다.
// memo[N/3][N/3] ... memo[N/3][2N/3] = false
// memo[N/3 + 1][N/3] ... memo[N/3 +1][2N/3] = false
// ...
// memo[2N/3][N/3] ... memo[2N/3][2N/3] = false

// memo[N/3^2][N/3^2] ...

let N = 27;
let memo = [];
for (let i = 0; i < N; i++) {
        memo[i] = new Array(N).fill(true);
}

// N = 27
// 첫번째는 (9,9)... (18,18) 하나만 빼면 됨.
// [(N/3, N/3), ... (2N/3, 2N/3)]
//
// 두번째는 (3*3) * 3^2
// [(3,3), ... (6,6)], [(3,12), ...(6,15)], [(3,21), ... (6,24)]
// [(12,3), ... (15,6)], [(12,12), ...(15,15)], [(12,21), ... (15,24)]
// [(21,3), ... (24,6)], [(21,12), ...(24,15)], [(21,21), ... (24,24)]
//
// [(N/9, N/9), ...(2N/9, 2N/9)], [(N/9, 4N/9), ...(2N/9, 5N/9)], [(N/9, 7N/9), ... (2N/9, 8N/9)]
// [(4N/9, N/9), ...(5N/9, 2N/9)], [(4N/9, 4N/9), ...(5N/9, 5N/9)], [(4N/9, 7N/9), ... (5N/9, 8N/9)]
// [(7N/9, N/9), ... (8N/9, 2N/9)], [(7N/9, 4N/9), ...(8N/9, 5N/9)], [(7N/9, 7N/9), ...(8N/9, 8N/9)]
//
// N = 3^n 이면
// [(N/3^n, N/3^n), ... ((N+1)/3^n, (N+1)/3^n)], [(N/3^n, (N+3)/3^n), ... ((N+1)/3^n, (N+4)/3^n)]

let re = N;

p = 0;
while (re % 3 == 0) {
        p++;
        re /= 3;
}

let copy = N;

let n = 1;
while (N % 3 ** n == 0) {
        let submemo = [];
        // 9 // 3, 12, 21 // 1 4 7 10 13 16 19 22 25
        for (let i = N / 3 ** n; i < N; i += N / 3 ** (n - 1)) {
                // n = 2 > j = 3 ~ 3+3, 12 ~ 12 + 3, 21 ~ 21 + 3
                for (let j = i; j < i + N / 3 ** n; j += N / 3 ** (n - 1)) {
                        submemo.push(j);
                }

                if (submemo.length == N / 3 ** (p - n + 1)) {
                        // [ 3, 12, 21 ], 정사각형 변의 길이 = N/3**n
                        for (let j = 0; j < submemo.length; j++) {
                                for (
                                        let k = submemo[j];
                                        k < submemo[j] + N / 3 ** n;
                                        k++
                                ) {
                                        // memo[k][k] ~ memo[k][k+t]
                                }
                        }
                }

                // memo[i][i], memo[i][i+1], ... memo[i][i+ N/3**n]
                // memo[i+1][i], ... memo[i+1][i+i]
                // memo[i+i][i], ... memo[i+i][i+i]
        }
        n++;
        //if (n == 3) break;
        // break;
}

let ans = "";

for (let i = 0; i < memo.length; i++) {
        for (let j = 0; j < memo[i].length; j++) {
                if (memo[i][j] == true) {
                        ans += "*";
                } else {
                        ans += " ";
                }
        }
        ans += "\n";
}

console.log(ans);
