백트래킹 : 순열, 조합을 구할 떄 사용한다.

N개 중 중복 없이 M개를 뽑는데,

가능한 모든 수열을 전부 나열해야 함.

백트래킹을 사용해 비어있는 리스트에서 시작해,

수를 하나씩 추가하면서 길이 M인 수열이 완성되면 출력 후,

이전 depth로 돌아가는 식으로 구현한다.

우선 DFS를 알아야 함.

## DFS (Depth First Search, 깊이 우선 탐색)

ref : https://velog.io/@songyw0517/DFS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

최대한 깊이 내려간 뒤, 더 이상 내려갈 곳이 없는 경우 돌아와 옆으로 이동.
그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘.
스택을 이용해 구현한다.
모든 노드를 방문해야 할 때 사용한다.

### 과정

1. 시작 노드를 스택에 넣고, 방문 처리를 한다.

2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면, 인접 노드를 스택에 넣고 방문처리 한다.

3. 방문하지 않은 노드가 없다면 스택에서 최상단 노드를 꺼낸다.

4. 2번을 수행할 수 없을 때까지 반복한다.

### 시간 복잡도

그래프를 어떤 방법으로 구현했는지에 따라 달라진다.

1. 인접 행렬 구현
   고등학교에서 배운 그 인접행렬 맞다.
   두 노드가 연결되어있으면 1, 없으면 0인 n\*n 행렬
   코드로는 이중배열을 사용하면 된다.
   i, j 노드의 연결여부를 확인할 경우 arr[i][j]로 바로 접근 가능하므로 O(1)의 시간 복잡도를 가진다.
   i 노드의 연결된 모든 노드를 확인하려면 arr[i][0] ~ arr[i][N-1]을 전부 확인해야 한다. 이 건 O(N)의 시간 복잡도를 가짐.

2. 인접 리스트 구현
   그래프의 한 노드에서 연결된 노드들을 하나의 연결 리스트로 표현하는 방법
   리스트에서 노드 순서는 의미 없음.
   i와 연결된 모든 노드를 확인하고자 할 때의 시간 복잡도는 O(N) (최대 : 모든 노드와 연결된 경우)
   i, j의 연결 여부를 확인할 때 adjList[i]를 순회하며 j를 탐색하므로 시간 복잡도는 O(N)
   ref : https://sarah950716.tistory.com/12

### 예시

ref : https://velog.io/@dev-redo/%EB%B0%B1%EC%A4%80-15649%EB%B2%88-N%EA%B3%BC-M1-NodeJS

e.g. N = 4 (1~4), M = 3

1. 빈 리스트로 시작한다.
   ?, ?, ?

2. 1부터 채운다.
   1, ?, ?

3. 다음을 2, 3으로 채운다.
   1, 2, ? > 1, 2, 3

4. 완성이 되었으니 출력하고, 이전 상태로 돌아간다.
   console.log(1, 2, 3)
   1, 2, ?

5. 3번째 자리에 수를 채우는데 3은 썻고, 4를 채운다.
   1, 2, 4

6. 출력 후, 이전 상태로 돌아간다.
   1, 2, ?

7. 이 상태에서도 새 수열을 만들 수 없다. 하나 더 이전으로 돌아간다.
   1, ?, ?

8. 두 번째 칸을 다시 채우는데, 2는 사용했고, 3을 사용한다.
   1, 3, ?

9. 반복...

### 구현

그래서 이걸 어떻게 구현해야 하나?

이래서 앞에 재귀함수 챕터가 있던거구나..

```js
// 수열 상태를 저장할 배열
const seq = [...Array(m)].fill(0);

// 방문한 (시퀀스에 다시 사용할 수 없는 숫자들을 저장한 배열)
const visited = [...Array(n)].fill(false);

// 모든 수열의 조합을 저장할 문자열
let result = "";

// 수열을 만들 함수.
const dfs = (k) => {
        // 인수 k는 현 수열의 원소 갯수를 의미하며,
        // 인수가 m이 될 때까지 재귀적으로 호출하고 m이 되면 수열을 출력한다.
        if (k === m) {
                const arr = [];
                for (let i = 0; i < m; i++) {
                        arr.push(seq[i]);
                }

                return (result += `${arr.join(" ")}\n`);
        }

        // 1~n중의 숫자를 고른다.
        for (let i = 1; i <= n; i++) {
                // 이미 고른 수는 다시 고를 수 없음
                if (!visited[i]) {
                        // seq의 k번째 인덱스를 i로 설정
                        seq[k] = i;
                        visited[i] = true;

                        // 다음 숫자를 고르는 함수 호출
                        dfs(k + 1);
                        visited[i] = false;
                }
        }
};
```
