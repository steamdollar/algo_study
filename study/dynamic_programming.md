# 동적 계획법 (dynamic programming, DP)

최적화 이론의 한 기술로,

특정 범위까지의 값을 구하기 위해 그것과 다른 범위까지의 값을 이용해

효율적으로 값을 구하는 알고리즘 설계 기법이다.

동적 계획법은 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고,

과거에 구한 해를 활용하는 방식의 알고리즘을 총칭한다.

답을 구하기 위해 한 계산을 반복해야하는 종류의 문제의 구조를 `최적 부분 구조`라고 하는데,

이런 문제에서 `동적 계획법`은 효과를 발휘한다.

사실 닉값을 잘 못한다. 프로그래밍, 다이나믹 모두와 큰 연관이 없다.

# 구현

기본적으로 분할 정복 알고리즘과 접근 방식이 비슷하다.

차이는 원래의 문제를 부분 문제로 나누는 방식에 있는데,

동적 계획법의 경우 주어진 문제를 나눌 때 부분 문제를 최대한 많이 이용하도록 나눈 후,

주어진 부분 문제의 정답을 한 번만 계산하고 저장한 뒤,

다시 이 부분 문제를 이용할 때는 저장해둔 답을 바로 이용함으로써 속도를 향상시킨다.

# 예시

쉬운 예시로 피보나치 수열 구하기가 있다. 이 수열은 다음과 같이 재귀함수 형태로 표현된다.

```
        a(0) = a(1) = 1
        a(n) = a(n-1) + a(n-2) (n>=2)
```

좀더 코드처럼 써보면

```js
const fibo = (n) => {
        if (n <= 1) {
                return 1;
        } else {
                return fibo(n - 1) + fibo(n - 2);
        }
};
```

함수가 호출되면 메모리의 스택에 데이터가 쌓인다. (매개 변수도 포함해서.. 함수 종료 후 어디로 돌아가야 하는지 등..)

함수가 계속 호출될수록 메모리에 쌓이는 것들이 증가하고, 이게 너무 심하면 스택 오버플로우가 발생해 프로그램이 튕겨버린다.

# 해결

동적 계획법에서는 이런 반복 계산에 의한 메모리 과부하를 막기 위해 이전에 계산한 값들을 배열에 저장한다. 대표적인 방식은 Top-down과 Bottom-up이다.

## Top down

큰 문제부터 시작해 계쏙 작은 문제로 분할해가며 푸는 것이다.

fibo(4)를 구하는 큰 문제는 fibo(3), fibo(2)를 구하는 작은 문제로 나눌 수 있다.
fibo(3)은 fibo(2), fibo(1)을 구하는 더 작은 문제로 나눌 수 있다.

구현은 다음과 같다.

```c
        // 메모이제이션 공간. 전역 변수이므로 0으로 초기화
        int memo[100]{}

        int fibo(uint n) {
                if ( n <= 1 ) {
                        return n
                }
                if (memo[n] != 0) {
                        return memo[n]
                }
                memo[n] = fibo(n-1) + fibo(n-2)
                return memo[n]
        }
```

## Bottom up

작은 문제부터 시작해 쌓아올려 큰 문제를 푸는 것이다. fibo(1), fibo(2)를 알면
fibo(3)을 알 수 있고, 다시 fibo(2), fibo(3)을 이용함녀 fibo(4)를 알 수 있고...
구현은 다음과 같다.

```js
let arr = [1, 1];
let last_pos = 1;

const f = (n) => {
        let i;
        if (arr[n - 1] == undefined) {
                for (i = last_pos + 1; i < n; i++) {
                        arr[i] = arr[i - 1] + arr[i - 2];
                }
                last_pos = n - 1;
        }
        return arr[n - 1];
};
```

이렇게 하면 숫자를 저장하는 공간이 필요한 대신, O(n)의 시간 복잡도로 구할 수 있다.

# 메모이제이션 (memoization)

동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장헀다가 꺼내 씀으로써
중복 계산을 방지할 수 있게 하는 기법이다.

동적 계획법의 핵심이 되는 기술로, 결국 메모리라는 공간 비용을 투입해 계산에 소요되는 시간 비용을 줄이는 방식이다.
메모이제이션은 학술적인 용어에 가깝고, 실전에서는 캐싱이라는 단어를 더 많이 사용한다.

상향식 풀이는 타불레이션 (tabulation)이라는 용어를 사용한다.
